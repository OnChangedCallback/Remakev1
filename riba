print("load started")

-- Глобальная таблица переменных
vars = {
    -- Services
    Players = game:GetService("Players"),
    RunService = game:GetService("RunService"),
    UserInputService = game:GetService("UserInputService"),
    TweenService = game:GetService("TweenService"),
    Workspace = game:GetService("Workspace"),
    HttpService = game:GetService("HttpService"),
    TeleportService = game:GetService("TeleportService"),
    MarketplaceService = game:GetService("MarketplaceService"),
    ReplicatedStorage = game:GetService("ReplicatedStorage"),
    Lighting = game:GetService("Lighting"),
    
    -- Player
    LocalPlayer = game:GetService("Players").LocalPlayer,
    
    -- Math & Constructors
    Vector2new = Vector2.new,
    Vector3new = Vector3.new,
    CFramenew = CFrame.new,
    CFrameAngles = CFrame.Angles,
    Color3new = Color3.new,
    Color3fromRGB = Color3.fromRGB,
    Color3fromHex = Color3.fromHex,
    UDim2new = UDim2.new,
    UDimnew = UDim.new,
    ColorSeqnew = ColorSequence.new,
    ColorSeqKey = ColorSequenceKeypoint.new,
    Instancenew = Instance.new,
    
    -- Drawing
    Drawingnew = Drawing and Drawing.new,
    
    -- Math functions
    math_random = math.random,
    math_min = math.min,
    math_max = math.max,
    math_floor = math.floor,
    math_ceil = math.ceil,
    math_abs = math.abs,
    math_sqrt = math.sqrt,
    math_rad = math.rad,
    math_deg = math.deg,
    math_sin = math.sin,
    math_cos = math.cos,
    math_tan = math.tan,
    math_atan2 = math.atan2,
    math_huge = math.huge,
    
    -- String functions
    str_find = string.find,
    str_sub = string.sub,
    str_format = string.format,
    str_lower = string.lower,
    str_upper = string.upper,
    str_match = string.match,
    
    -- Table functions
    tbl_insert = table.insert,
    tbl_remove = table.remove,
    tbl_find = table.find,
    tbl_concat = table.concat,
    
    -- Task functions
    task_wait = task.wait,
    task_spawn = task.spawn,
    task_defer = task.defer,
    
    -- Other
    tick = tick,
    time = time,
    os_date = os.date,
    os_time = os.time,
    pairs = pairs,
    ipairs = ipairs,
    next = next,
    pcall = pcall,
    xpcall = xpcall,
    typeof = typeof,
    type = type,
    tostring = tostring,
    tonumber = tonumber,
    rawget = rawget,
    rawset = rawset,
    setmetatable = setmetatable,
    getmetatable = getmetatable
}

-- Загрузка UI библиотеки
local library, _, _, _, _, themes, flags = loadstring(game:HttpGet("https://raw.githubusercontent.com/OnChangedCallback/Remakev1/refs/heads/main/lib"))()
print("uiloaded")

-- Утилити библиотека (должна быть до всего остального кода)
local utility = {}
local framework = {connections = {}}

-- Глобальные переменные
local config_holder = nil
local default_config = nil
local game_name_cache = nil
local watermark = nil
local radar = nil

-- Utility функции
do
    -- Получение имени игры с кешированием
    utility.get_game_name = function()
        if game_name_cache ~= nil then
            return game_name_cache
        end
        local success, info = pcall(function()
            return vars.MarketplaceService:GetProductInfo(game.PlaceId)
        end)
        local name = success and info and info.Name or tostring(game.PlaceId)
        game_name_cache = name
        return name
    end
    
    -- Создание уведомления
    utility.notify = function(text, duration)
        library:notification({text = text, time = duration or 3})
    end
    
    -- Безопасное получение конфига
    utility.get_config_path = function(name)
        return library.directory .. "/configs/" .. name .. ".cfg"
    end
    
    -- Проверка существования конфига
    utility.config_exists = function(name)
        if not name or name == "" then return false end
        local path = utility.get_config_path(name)
        return isfile and isfile(path) or false
    end
    
    -- Сохранение конфига
    utility.save_config = function(name)
        if not name or name == "" then
            utility.notify("Enter config name first!", 3)
            return false
        end
        writefile(utility.get_config_path(name), library:get_config())
        library:config_list_update()
        utility.notify("Saved config: " .. name, 3)
        return true
    end
    
    -- Загрузка конфига
    utility.load_config = function(name)
        if not name or name == "" then
            utility.notify("Select a config first!", 3)
            return false
        end
        if not utility.config_exists(name) then
            utility.notify("Config does not exist: " .. name, 3)
            return false
        end
        library:load_config(readfile(utility.get_config_path(name)))
        utility.notify("Loaded config: " .. name, 3)
        return true
    end
    
    -- Удаление конфига
    utility.delete_config = function(name)
        if not name or name == "" then
            utility.notify("Select a config first!", 3)
            return false
        end
        if not utility.config_exists(name) then
            utility.notify("Config does not exist: " .. name, 3)
            return false
        end
        delfile(utility.get_config_path(name))
        library:config_list_update()
        utility.notify("Deleted config: " .. name, 3)
        return true
    end
    
    -- Копирование в буфер обмена
    utility.copy_to_clipboard = function(text)
        if setclipboard then
            setclipboard(text)
            return true
        end
        return false
    end
    
    -- Функция для обновления текста watermark
    utility.update_watermark_text = function()
        local watermark_type = flags["watermark_type"]
        local parts = {}
        
        local get_game_name = function()
            if game_name_cache ~= nil then
                return game_name_cache
            end
            local success, info = pcall(function()
                return vars.MarketplaceService:GetProductInfo(game.PlaceId)
            end)
            local name = success and info and info.Name or tostring(game.PlaceId)
            game_name_cache = name
            return name
        end
        
        if type(watermark_type) == "table" then
            local selected = {}
            for _, option in next, watermark_type do
                selected[option] = true
            end
            
            if selected["Date"] then
                parts[#parts + 1] = os.date("%y:%m:%d")
            end
            if selected["Time"] then
                parts[#parts + 1] = os.date("%H:%M:%S")
            end
            if selected["Place"] then
                parts[#parts + 1] = utility.get_game_name()
            end
            if selected["User"] then
                parts[#parts + 1] = vars.LocalPlayer and vars.LocalPlayer.Name or "?"
            end
        end
        
        if #parts == 0 then
            parts[1] = os.date("%H:%M:%S")
        end
        
        return "luasex - " .. table.concat(parts, " - ")
    end
    
    -- Безопасное выполнение HTTP запроса с повторными попытками
    utility.http_get_with_retry = function(url, attempts)
        attempts = attempts or 5
        local delay = 1
        for i = 1, attempts do
            local ok, body = pcall(function()
                return game:HttpGetAsync(url)
            end)
            if ok then
                return true, body
            else
                local msg = tostring(body)
                if vars.str_find(msg, "429") or vars.str_find(msg, "Too Many Requests") then
                    vars.task_wait(delay + (vars.math_random(0, 250) / 1000))
                    delay = vars.math_min(delay * 2, 8)
                else
                    return false, msg
                end
            end
        end
        return false, "Max attempts reached"
    end
    
    -- Получение списка серверов
    utility.fetch_servers = function()
        local url = "https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"
        local ok, body = utility.http_get_with_retry(url)
        if not ok then
            utility.notify("Failed to fetch servers: " .. tostring(body), 3)
            return nil
        end
        
        local ok2, decoded = pcall(function()
            return vars.HttpService:JSONDecode(body)
        end)
        if not ok2 then
            utility.notify("Failed to decode server list", 3)
            return nil
        end
        
        return decoded
    end
    
    -- Телепорт на новый сервер
    utility.join_new_server = function(max_players)
        local servers = utility.fetch_servers()
        if not servers or not servers.data or #servers.data == 0 then
            utility.notify("Сервера недоступны или пустой список", 3)
            return
        end
        
        local candidates = {}
        for _, s in ipairs(servers.data) do
            if s.id ~= game.JobId and s.playing < s.maxPlayers and s.playing <= (max_players or 15) then
                vars.tbl_insert(candidates, s)
            end
        end
        
        if #candidates == 0 then
            utility.notify("Свободных серверов не найдено", 3)
            return
        end
        
        local target = candidates[vars.math_random(1, #candidates)]
        vars.TeleportService:TeleportToPlaceInstance(game.PlaceId, target.id, vars.LocalPlayer)
    end
end

-- Загрузка ESP библиотеки
do
    loadstring(game:HttpGet("https://raw.githubusercontent.com/OnChangedCallback/Remakev1/refs/heads/main/esp"))()
    print("esploaded")
end

-- Создание UI
do
    -- Создание окна
    local window = library:window({
        name = "luasex",
        size = vars.UDim2new(0, 780, 0, 639)
    })
    
    -- Создание вкладок
    _G.RageTab = window:tab({ name = "Rage", enabled = true })
    _G.EspTab = window:tab({ name = "Esp", enabled = true })
    _G.VisualsTab = window:tab({ name = "Visuals", enabled = true })
    _G.ConfigTab = window:tab({ name = "Config", enabled = true })
    _G.window = window
    
    -- Создание HUD элементов
    watermark = library:watermark({
        text = "luasex - " .. vars.os_date("%H:%M:%S")
    })
    
    radar = library:radar({
        enabled = false,
        size = 200
    })
end

-- Config Tab содержимое
do
    local ConfigTab = _G.ConfigTab
    local config_column = ConfigTab:column()
    local config_section = config_column:section({name = "Options"})
    
    -- Сохраняем дефолтный конфиг
    default_config = library:get_config()
    
    -- Список конфигов
    config_holder = config_section:list({flag = "config_name_list"})
    
    -- Текстбокс для имени конфига
    config_section:textbox({
        flag = "config_name_text_box",
        placeholder = "Config name"
    })
    
    -- Кнопки управления конфигами
    config_section:button_holder({})
    
    config_section:button({
        name = "Create",
        callback = function()
            local config_name = flags["config_name_text_box"]
            utility.save_config(config_name)
        end
    })
    
    config_section:button({
        name = "Delete",
        callback = function()
            local selected_config = flags["config_name_list"]
            utility.delete_config(selected_config)
        end
    })
    
    config_section:button_holder({})
    
    config_section:button({
        name = "Load",
        callback = function()
            local selected_config = flags["config_name_list"]
            utility.load_config(selected_config)
        end
    })
    
    config_section:button({
        name = "Save",
        callback = function()
            local selected_config = flags["config_name_list"]
            utility.save_config(selected_config)
        end
    })
    
    config_section:button_holder({})
    
    config_section:button({
        name = "Refresh Configs",
        callback = function()
            library:config_list_update()
            utility.notify("Refreshed config list", 2)
        end
    })
    
    config_section:button_holder({})
    
    config_section:button({
        name = "Reset to Default",
        callback = function()
            library:load_config(default_config)
            utility.notify("Reset to default config", 3)
        end
    })
    
    config_section:button({
        name = "Unload Menu",
        callback = function()
            library:load_config(default_config)
            for _, gui in pairs(library.guis) do
                gui:Destroy()
            end
            for _, connection in pairs(library.connections) do
                connection:Disconnect()
            end
        end
    })
    
    -- Мульти-секция для Theme, Game, HUD
    local theme_section, game_section, hud_section = ConfigTab:column():multi_section({
        names = {"Theme", "Game", "HUD"}
    })
    
    -- Theme секция
    theme_section:label({name = "Accent"}):colorpicker({
        name = "Accent",
        color = vars.Color3new(139/255, 92/255, 246/255), -- #8B5CF6
        flag = "theme_accent",
        callback = function(color, transparency)
            library:update_theme("accent", color)
        end
    })
    
    local contrast_label = theme_section:label({name = "Contrast"})
    contrast_label:colorpicker({
        name = "Low",
        color = vars.Color3new(30/255, 30/255, 30/255), -- #1E1E1E
        flag = "theme_low",
        callback = function(color)
            if flags["theme_high"] and flags["theme_low"] then
                library:update_theme("contrast", vars.ColorSeqnew({
                    vars.ColorSeqKey(0, flags["theme_low"].Color),
                    vars.ColorSeqKey(1, flags["theme_high"].Color)
                }))
            end
        end
    })
    contrast_label:colorpicker({
        name = "High",
        color = vars.Color3new(45/255, 45/255, 45/255), -- #2D2D2D
        flag = "theme_high",
        callback = function(color)
            if flags["theme_high"] and flags["theme_low"] then
                library:update_theme("contrast", vars.ColorSeqnew({
                    vars.ColorSeqKey(0, flags["theme_low"].Color),
                    vars.ColorSeqKey(1, flags["theme_high"].Color)
                }))
            end
        end
    })
    
    local inline_label = theme_section:label({name = "Inline"})
    inline_label:colorpicker({
        name = "Inline",
        color = vars.Color3new(60/255, 60/255, 60/255), -- #3C3C3C
        flag = "theme_inline",
        callback = function(color, transparency)
            library:update_theme("inline", color)
        end
    })
    inline_label:colorpicker({
        name = "Outline",
        color = vars.Color3new(0, 0, 0), -- #000000
        flag = "theme_outline",
        callback = function(color, transparency)
            library:update_theme("outline", color)
        end
    })
    
    local text_label = theme_section:label({name = "TextColor"})
    text_label:colorpicker({
        name = "Main",
        color = vars.Color3new(1, 1, 1), -- #FFFFFF
        flag = "theme_text",
        callback = function(color, transparency)
            library:update_theme("text", color)
        end
    })
    text_label:colorpicker({
        name = "Outline",
        color = vars.Color3new(0, 0, 0), -- #000000
        flag = "theme_text_outline",
        callback = function(color, transparency)
            library:update_theme("text_outline", color)
        end
    })
    
    theme_section:label({name = "Glow"}):colorpicker({
        name = "Glow",
        color = vars.Color3new(139/255, 92/255, 246/255), -- #8B5CF6
        flag = "theme_glow",
        callback = function(color, transparency)
            library:update_theme("glow", color)
        end
    })
    
    -- HUD секция
    hud_section:label({name = "UI Bind"}):keybind({
        key = Enum.KeyCode.Insert,
        flag = "ui_bind",
        callback = function(key)
            _G.window.visible = not _G.window.visible
        end
    })
    
    hud_section:toggle({
        name = "Keybind List",
        flag = "keybind_list",
        callback = function(enabled)
            if library.keybind_list_frame then
                library.keybind_list_frame.Visible = enabled
            end
        end
    })
    
    local watermark_toggle = hud_section:toggle({
        name = "Watermark",
        flag = "watermark",
        callback = function(enabled)
            watermark.set_visible(enabled)
            if enabled then
                watermark.change_text(utility.update_watermark_text())
            end
        end
    })
    
    hud_section:dropdown({
        name = "Watermark Type",
        flag = "watermark_type",
        items = {"Time", "Date", "Place", "User"},
        multi = true,
        default = {"Time"},
        callback = function(selected)
            watermark.change_text(utility.update_watermark_text())
        end
    })
    
    local radar_toggle = hud_section:toggle({
        name = "Radar",
        flag = "hud_radar",
        callback = function(enabled)
            radar.set_visible(enabled)
            if enabled then
                -- Добавляем всех игроков при включении радара
                for _, player in ipairs(vars.Players:GetPlayers()) do
                    if player ~= vars.LocalPlayer and radar and radar.add_dot then
                        radar.add_dot(player)
                    end
                end
            end
        end
    })
    
    hud_section:slider({
        name = "Radar Zoom",
        flag = "radar_zoom",
        min = 0.1,
        max = 2,
        default = 1,
        interval = 0.1,
        callback = function(value)
            radar.set_zoom(value)
        end
    })
    
    -- Game секция
    game_section:button_holder({})
    
    game_section:button({
        name = "Copy JobId",
        callback = function()
            utility.copy_to_clipboard(game.JobId)
            utility.notify("Copied JobId to clipboard", 2)
        end
    })
    
    game_section:button({
        name = "Copy GameID",
        callback = function()
            utility.copy_to_clipboard(tostring(game.GameId))
            utility.notify("Copied GameId to clipboard", 2)
        end
    })
    
    game_section:button_holder({})
    
    game_section:button({
        name = "Copy Join Script",
        callback = function()
            local script = vars.str_format(
                'game:GetService("TeleportService"):TeleportToPlaceInstance(%d, "%s", game.Players.LocalPlayer)',
                game.PlaceId, game.JobId
            )
            utility.copy_to_clipboard(script)
            utility.notify("Copied join script to clipboard", 2)
        end
    })
    
    game_section:button_holder({})
    
    game_section:button({
        name = "Rejoin",
        callback = function()
            vars.TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, vars.LocalPlayer)
        end
    })
    
    game_section:button_holder({})
    
    game_section:button({
        name = "Join New Server",
        callback = function()
            utility.join_new_server(flags["max_players"])
        end
    })
    
    game_section:slider({
        name = "Max Players",
        flag = "max_players",
        min = 0,
        max = 40,
        default = 15,
        interval = 1
    })
end

-- Framework: Radar система
do
    framework.add_player_to_radar = function(player)
        if player ~= vars.LocalPlayer and radar and radar.add_dot then
            radar.add_dot(player)
        end
    end
    
    framework.remove_player_from_radar = function(player)
        if radar and radar.remove_dot then
            radar.remove_dot(player)
        end
    end
    
    framework.update_radar_positions = function()
        if radar and radar.update_dot then
            for _, player in ipairs(vars.Players:GetPlayers()) do
                if player ~= vars.LocalPlayer then
                    local character = player.Character
                    local root = character and character:FindFirstChild("HumanoidRootPart")
                    if root then
                        radar.update_dot(player, root.Position)
                    end
                end
            end
        end
    end
    
    -- Подключаем события
    vars.tbl_insert(library.connections, vars.Players.PlayerAdded:Connect(framework.add_player_to_radar))
    vars.tbl_insert(library.connections, vars.Players.PlayerRemoving:Connect(framework.remove_player_from_radar))
    
    -- Запускаем обновление позиций
    local radar_connection = vars.RunService.RenderStepped:Connect(framework.update_radar_positions)
    vars.tbl_insert(library.connections, radar_connection)
end

-- Обновление watermark каждую секунду
do
    vars.task_spawn(function()
        while vars.task_wait(1) do
            if flags["watermark"] then
                watermark.change_text(utility.update_watermark_text())
            end
        end
    end)
end

-- ESP Tab содержимое
do
    local EspTab = _G.EspTab
    -- Создаем колонки для ESP вкладки
    local esp_column1 = EspTab:column()
    local esp_column2 = EspTab:column()
    local esp_column3 = EspTab:column()
    
    -- Main ESP Toggle
    local main_section = esp_column1:section({name = "Main ESP"})
    
    main_section:toggle({
        name = "Enable ESP",
        flag = "esp_enable",
        default = false,
        callback = function(enabled)
            if enabled then
                _G.ESP_Start()
            else
                _G.ESP_Stop()
            end
        end
    })
    
    main_section:slider({
        name = "Text Spacing",
        flag = "text_spacing",
        min = 5,
        max = 25,
        default = 12,
        interval = 1,
        callback = function(value)
            _G.ESP_Config.Text.Spacing = value
        end
    })
    
    -- Boxes секция
    local boxes_section = esp_column1:section({name = "Boxes"})
    
    -- Enabled тогл с колорпикером
    local box_enabled_toggle = boxes_section:toggle({
        name = "Enabled",
        flag = "box_enable",
        callback = function(enabled)
            _G.ESP_Config.Box.Enable = enabled
        end
    })
    box_enabled_toggle:colorpicker({
        name = "Box Color",
        color = vars.Color3new(1, 1, 1),
        flag = "box_color",
        callback = function(color, transparency)
            _G.ESP_Config.Box.Color = color
        end
    })
    
    -- Filled тогл с колорпикером заливки
    local box_filled_toggle = boxes_section:toggle({
        name = "Filled",
        flag = "box_fill",
        callback = function(enabled)
            _G.ESP_Config.Box.Filled.Enable = enabled
        end
    })
    box_filled_toggle:colorpicker({
        name = "Fill Color",
        color = vars.Color3new(1, 1, 1),
        flag = "box_fill_color",
        callback = function(color, transparency)
            _G.ESP_Config.Box.Filled.Color = color
            _G.ESP_Config.Box.Filled.Transparency = transparency or 0.5
        end
    })
    
    -- Прозрачность заливки (dependency)
    boxes_section:slider({
        name = "Fill Transparency",
        flag = "box_fill_transparency",
        min = 0,
        max = 1,
        default = 0.5,
        interval = 0.05,
        dependency = "box_fill",
        callback = function(value)
            _G.ESP_Config.Box.Filled.Transparency = value
        end
    })
    
    -- Gradient тогл с двумя колорпикерами
    local box_gradient_toggle = boxes_section:toggle({
        name = "Gradient",
        flag = "box_gradient",
        callback = function(enabled)
            _G.ESP_Config.Box.Filled.Gradient.Enable = enabled
        end
    })
    box_gradient_toggle:colorpicker({
        name = "Start",
        color = vars.Color3new(1, 1, 1),
        flag = "box_gradient_start",
        callback = function(color)
            _G.ESP_Config.Box.Filled.Gradient.Color.Start = color
        end
    })
    box_gradient_toggle:colorpicker({
        name = "End",
        color = vars.Color3new(0, 0, 1),
        flag = "box_gradient_end",
        callback = function(color)
            _G.ESP_Config.Box.Filled.Gradient.Color.End = color
        end
    })
    
    -- Rotating тогл с слайдером скорости (dependency)
    boxes_section:toggle({
        name = "Rotating",
        flag = "box_gradient_rotating",
        dependency = "box_gradient",
        callback = function(enabled)
            _G.ESP_Config.Box.Filled.Gradient.Rotating.Enable = enabled
        end
    })
    
    boxes_section:slider({
        name = "Rotating Speed",
        flag = "box_gradient_rotating_speed",
        min = 0.1,
        max = 5.0,
        default = 1.0,
        interval = 0.1,
        dependency = "box_gradient_rotating",
        callback = function(value)
            _G.ESP_Config.Box.Filled.Gradient.Rotating.Speed = value
        end
    })
    
    -- Глобально отключаем teamcheck для Name
    _G.ESP_Config.Text.Name.Teamcheck = false
    
    -- Новая колонка для текстов: 4 отдельные секции с одинаковыми контролами
    -- Name
    local name_section = esp_column3:section({name = "Name"})
    local name_toggle = name_section:toggle({
        name = "Enabled",
        flag = "text_name_enable",
        callback = function(enabled)
            _G.ESP_Config.Text.Name.Enable = enabled
            _G.ESP_Config.Text.Name.Size = 13
            _G.ESP_Config.Text.Name.Font = "TahomaBold"
            if _G.ESP_Config.Text.Name.Teamcheck ~= nil then
                _G.ESP_Config.Text.Name.Teamcheck = false
            end
        end
    })
    name_toggle:colorpicker({
        name = "Text Color",
        color = vars.Color3new(1, 1, 1),
        flag = "text_name_color",
        callback = function(color)
            _G.ESP_Config.Text.Name.Color = color
        end
    })
    name_section:dropdown({
        name = "Side",
        flag = "text_name_side",
        items = {"Top", "Bot"},
        default = "Top",
        dependency = "text_name_enable",
        callback = function(selected)
            _G.ESP_Config.Text.Name.Side = selected
        end
    })
    -- Фиксированный размер для Name = 13, шрифт TahomaBold

    -- Distance
    local distance_section = esp_column3:section({name = "Distance"})
    local distance_toggle = distance_section:toggle({
        name = "Enabled",
        flag = "text_studs_enable",
        callback = function(enabled)
            _G.ESP_Config.Text.Studs.Enable = enabled
            _G.ESP_Config.Text.Studs.Size = 12
            _G.ESP_Config.Text.Studs.Font = "TahomaBold"
        end
    })
    distance_toggle:colorpicker({
        name = "Text Color",
        color = vars.Color3new(1, 1, 1),
        flag = "text_studs_color",
        callback = function(color)
            _G.ESP_Config.Text.Studs.Color = color
        end
    })
    distance_section:dropdown({
        name = "Side",
        flag = "text_studs_side",
        items = {"Top", "Bot"},
        default = "Bot",
        dependency = "text_studs_enable",
        callback = function(selected)
            _G.ESP_Config.Text.Studs.Side = selected
        end
    })
    -- Фиксированный размер для Distance = 12, шрифт TahomaBold

    -- Tool
    local tool_section = esp_column3:section({name = "Tool"})
    local tool_toggle = tool_section:toggle({
        name = "Enabled",
        flag = "text_tool_enable",
        callback = function(enabled)
            _G.ESP_Config.Text.Tool.Enable = enabled
            _G.ESP_Config.Text.Tool.Size = 12
            _G.ESP_Config.Text.Tool.Font = "TahomaBold"
        end
    })
    tool_toggle:colorpicker({
        name = "Text Color",
        color = vars.Color3new(1, 1, 1),
        flag = "text_tool_color",
        callback = function(color)
            _G.ESP_Config.Text.Tool.Color = color
        end
    })
    tool_section:dropdown({
        name = "Side",
        flag = "text_tool_side",
        items = {"Top", "Bot"},
        default = "Bot",
        dependency = "text_tool_enable",
        callback = function(selected)
            _G.ESP_Config.Text.Tool.Side = selected
        end
    })
    -- Фиксированный размер для Tool = 12, шрифт TahomaBold

    -- State
    local state_section = esp_column3:section({name = "State"})
    local state_toggle = state_section:toggle({
        name = "Enabled",
        flag = "text_state_enable",
        callback = function(enabled)
            _G.ESP_Config.Text.State.Enable = enabled
            _G.ESP_Config.Text.State.Size = 12
            _G.ESP_Config.Text.State.Font = "TahomaBold"
        end
    })
    state_toggle:colorpicker({
        name = "Text Color",
        color = vars.Color3new(1, 1, 1),
        flag = "text_state_color",
        callback = function(color)
            _G.ESP_Config.Text.State.Color = color
        end
    })
    state_section:dropdown({
        name = "Side",
        flag = "text_state_side",
        items = {"Top", "Bot"},
        default = "Bot",
        dependency = "text_state_enable",
        callback = function(selected)
            _G.ESP_Config.Text.State.Side = selected
        end
    })
    -- Фиксированный размер для State = 12, шрифт TahomaBold
    
    -- Bars секция (вторая колонка)
    local health_section = esp_column2:section({name = "Health Bar"})
    
    -- Health: Enabled + 3 градиентных цвета
    local health_toggle = health_section:toggle({
        name = "Enabled",
        flag = "bars_health_enable",
        callback = function(enabled)
            _G.ESP_Config.Bars.Health.Enable = enabled
            _G.ESP_Config.Bars.Health.Lerp = true -- лерп всегда включен
        end
    })
    health_toggle:colorpicker({
        name = "Color 1",
        color = vars.Color3new(0, 1, 0),
        flag = "bars_health_color1",
        callback = function(color)
            _G.ESP_Config.Bars.Health.Color1 = color
        end
    })
    health_toggle:colorpicker({
        name = "Color 2",
        color = vars.Color3new(0, 1, 0),
        flag = "bars_health_color2",
        callback = function(color)
            _G.ESP_Config.Bars.Health.Color2 = color
        end
    })
    
    health_section:dropdown({
        name = "Side",
        flag = "bars_health_side",
        items = {"Left", "Right", "Top", "Bot"},
        default = "Right",
        dependency = "bars_health_enable",
        callback = function(selected)
            _G.ESP_Config.Bars.Health.Side = selected
        end
    })
    
    health_section:slider({
        name = "Width",
        flag = "bars_health_width",
        min = 1,
        max = 10,
        default = 3,
        interval = 1,
        dependency = "bars_health_enable",
        callback = function(value)
            _G.ESP_Config.Bars.Health.Width = value
        end
    })
    
    health_section:slider({
        name = "Offset",
        flag = "bars_health_offset",
        min = 0,
        max = 15,
        default = 4,
        interval = 1,
        dependency = "bars_health_enable",
        callback = function(value)
            _G.ESP_Config.Bars.Health.Offset = value
        end
    })
    
    -- Armor секция
    local armor_section = esp_column2:section({name = "Armor Bar"})
    
    -- Armor: Enabled + 3 градиентных цвета
    local armor_toggle = armor_section:toggle({
        name = "Enabled",
        flag = "bars_armor_enable",
        callback = function(enabled)
            _G.ESP_Config.Bars.Armor.Enable = enabled
            _G.ESP_Config.Bars.Armor.Lerp = true -- лерп всегда включен
        end
    })
    armor_toggle:colorpicker({
        name = "Color 1",
        color = vars.Color3new(0, 89/255, 1),
        flag = "bars_armor_color1",
        callback = function(color)
            _G.ESP_Config.Bars.Armor.Color1 = color
        end
    })
    armor_toggle:colorpicker({
        name = "Color 2",
        color = vars.Color3new(60/255, 97/255, 219/255),
        flag = "bars_armor_color2",
        callback = function(color)
            _G.ESP_Config.Bars.Armor.Color2 = color
        end
    })
    
    armor_section:dropdown({
        name = "Side",
        flag = "bars_armor_side",
        items = {"Left", "Right", "Top", "Bot"},
        default = "Bot",
        dependency = "bars_armor_enable",
        callback = function(selected)
            _G.ESP_Config.Bars.Armor.Side = selected
        end
    })
    
    armor_section:slider({
        name = "Width",
        flag = "bars_armor_width",
        min = 1,
        max = 10,
        default = 3,
        interval = 1,
        dependency = "bars_armor_enable",
        callback = function(value)
            _G.ESP_Config.Bars.Armor.Width = value
        end
    })
    
    armor_section:slider({
        name = "Offset",
        flag = "bars_armor_offset",
        min = 0,
        max = 15,
        default = 4,
        interval = 1,
        dependency = "bars_armor_enable",
        callback = function(value)
            _G.ESP_Config.Bars.Armor.Offset = value
        end
    })
end

-- Инициализация темы
library:update_theme("accent", vars.Color3new(139/255, 92/255, 246/255))
library:update_theme("contrast", vars.ColorSeqnew({
    vars.ColorSeqKey(0, vars.Color3new(30/255, 30/255, 30/255)),
    vars.ColorSeqKey(1, vars.Color3new(45/255, 45/255, 45/255))
}))
library:update_theme("inline", vars.Color3new(60/255, 60/255, 60/255))
library:update_theme("outline", vars.Color3new(0, 0, 0))
library:update_theme("text", vars.Color3new(1, 1, 1))
library:update_theme("text_outline", vars.Color3new(0, 0, 0))
library:update_theme("glow", vars.Color3new(139/255, 92/255, 246/255))

-- Обновляем список конфигов при загрузке
library:config_list_update()

print("load finished")
print("loadend")
