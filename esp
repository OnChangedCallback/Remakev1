-- Таблица vars с переменными
local vars = {
    -- Services
    Players = game:GetService("Players"),
    RunService = game:GetService("RunService"),
    UserInputService = game:GetService("UserInputService"),
    TweenService = game:GetService("TweenService"),
    Workspace = game:GetService("Workspace"),
    HttpService = game:GetService("HttpService"),
    TeleportService = game:GetService("TeleportService"),
    MarketplaceService = game:GetService("MarketplaceService"),
    
    -- Player
    LocalPlayer = game:GetService("Players").LocalPlayer,
    
    -- Math
    Vector2new = Vector2.new,
    Vector3new = Vector3.new,
    CFramenew = CFrame.new,
    Color3new = Color3.new,
    Color3Hex = Color3.fromHex,
    dim2 = UDim2.new,
    ColorSeq = ColorSequence.new,
    ColorSeqKey = ColorSequenceKeypoint.new,
    
    -- Other
    Drawing = Drawing.new,
    random = math.random,
    task_wait = task.wait,
    math_min = math.min,
    str_find = string.find
}

-- Загрузка библиотеки
local library, dim2, hex, rgbseq, rgbkey, themes, flags, random, lp = loadstring(game:HttpGet("https://raw.githubusercontent.com/OnChangedCallback/Remakev1/refs/heads/main/lib"))()

-- Загрузка ESP библиотеки
loadstring(game:HttpGet("https://raw.githubusercontent.com/OnChangedCallback/Remakev1/refs/heads/main/esp"))()

-- Создание окна
local window = library:window({
    name = "luasex",
    size = vars.dim2(0, 780, 0, 639)
})

-- Создание вкладок
local RageTab = window:tab({ name = "Rage", enabled = true })
local EspTab = window:tab({ name = "Esp", enabled = true })
local VisualsTab = window:tab({ name = "Visuals", enabled = true })
local ConfigTab = window:tab({ name = "Config", enabled = true })

-- Глобальные переменные для HUD элементов
local watermark = library:watermark({
    text = "Rebuild.gg - " .. os.date("%H:%M:%S")
})

local radar = library:radar({
    enabled = false,
    size = 200
})

-- Переменная для хранения dropdown конфигов
local config_holder = nil
local default_config = nil
local game_name_cache = nil

-- Утилити функции
local utility = {}

do
    -- Функция для обновления текста watermark
    utility.update_watermark_text = function()
        local watermark_type = flags["watermark_type"]
        local parts = {}
        
        local get_game_name = function()
            if game_name_cache ~= nil then
                return game_name_cache
            end
            local success, info = pcall(function()
                return vars.MarketplaceService:GetProductInfo(game.PlaceId)
            end)
            local name = success and info and info.Name or tostring(game.PlaceId)
            game_name_cache = name
            return name
        end
        
        if type(watermark_type) == "table" then
            local selected = {}
            for _, option in next, watermark_type do
                selected[option] = true
            end
            
            if selected["Date"] then
                parts[#parts + 1] = os.date("%y:%m:%d")
            end
            if selected["Time"] then
                parts[#parts + 1] = os.date("%H:%M:%S")
            end
            if selected["Place"] then
                parts[#parts + 1] = get_game_name()
            end
            if selected["User"] then
                parts[#parts + 1] = vars.LocalPlayer and vars.LocalPlayer.Name or "?"
            end
        end
        
        if #parts == 0 then
            parts[1] = os.date("%H:%M:%S")
        end
        
        return "Rebuild.gg - " .. table.concat(parts, " - ")
    end
    
    -- Глобальная функция для загрузки конфига
    getgenv().load_config = function(config_name)
        library:load_config(readfile(library.directory .. "/configs/" .. config_name .. ".cfg"))
    end
end

-- Config Tab содержимое
do
    local config_column = ConfigTab:column()
    local config_section = config_column:section({name = "Options"})
    
    -- Сохраняем дефолтный конфиг
    default_config = library:get_config()
    
    -- Список конфигов
    config_holder = config_section:list({flag = "config_name_list"})
    
    -- Текстбокс для имени конфига
    config_section:textbox({
        flag = "config_name_text_box",
        placeholder = "Config name"
    })
    
    -- Кнопки управления конфигами
    config_section:button_holder({})
    
    config_section:button({
        name = "Create",
        callback = function()
            local config_name = flags["config_name_text_box"]
            if config_name and config_name ~= "" then
                writefile(library.directory .. "/configs/" .. config_name .. ".cfg", library:get_config())
                library:config_list_update()
                library:notification({text = "Created config: " .. config_name, time = 3})
            else
                library:notification({text = "Enter config name first!", time = 3})
            end
        end
    })
    
    config_section:button({
        name = "Delete",
        callback = function()
            local selected_config = flags["config_name_list"]
            if selected_config and selected_config ~= "" then
                delfile(library.directory .. "/configs/" .. selected_config .. ".cfg")
                library:config_list_update()
                library:notification({text = "Deleted config: " .. selected_config, time = 3})
            else
                library:notification({text = "Select a config first!", time = 3})
            end
        end
    })
    
    config_section:button_holder({})
    
    config_section:button({
        name = "Load",
        callback = function()
            local selected_config = flags["config_name_list"]
            if selected_config and selected_config ~= "" then
                library:load_config(readfile(library.directory .. "/configs/" .. selected_config .. ".cfg"))
                library:notification({text = "Loaded config: " .. selected_config, time = 3})
            else
                library:notification({text = "Select a config first!", time = 3})
            end
        end
    })
    
    config_section:button({
        name = "Save",
        callback = function()
            local selected_config = flags["config_name_list"]
            if selected_config and selected_config ~= "" then
                writefile(library.directory .. "/configs/" .. selected_config .. ".cfg", library:get_config())
                library:config_list_update()
                library:notification({text = "Saved config: " .. selected_config, time = 3})
            else
                library:notification({text = "Select a config first!", time = 3})
            end
        end
    })
    
    config_section:button_holder({})
    
    config_section:button({
        name = "Refresh Configs",
        callback = function()
            library:config_list_update()
            library:notification({text = "Refreshed config list", time = 2})
        end
    })
    
    config_section:button_holder({})
    
    config_section:button({
        name = "Reset to Default",
        callback = function()
            library:load_config(default_config)
            library:notification({text = "Reset to default config", time = 3})
        end
    })
    
    config_section:button({
        name = "Unload Menu",
        callback = function()
            library:load_config(default_config)
            for _, gui in pairs(library.guis) do
                gui:Destroy()
            end
            for _, connection in pairs(library.connections) do
                connection:Disconnect()
            end
        end
    })
    
    -- Мульти-секция для Theme, Game, HUD
    local theme_section, game_section, hud_section = ConfigTab:column():multi_section({
        names = {"Theme", "Game", "HUD"}
    })
    
    -- Theme секция
    theme_section:label({name = "Accent"}):colorpicker({
        name = "Accent",
        color = vars.Color3new(139/255, 92/255, 246/255), -- #8B5CF6
        flag = "theme_accent",
        callback = function(color, transparency)
            library:update_theme("accent", color)
        end
    })
    
    local contrast_label = theme_section:label({name = "Contrast"})
    contrast_label:colorpicker({
        name = "Low",
        color = vars.Color3new(30/255, 30/255, 30/255), -- #1E1E1E
        flag = "theme_low",
        callback = function(color)
            if flags["theme_high"] and flags["theme_low"] then
                library:update_theme("contrast", vars.ColorSeq({
                    vars.ColorSeqKey(0, flags["theme_low"].Color),
                    vars.ColorSeqKey(1, flags["theme_high"].Color)
                }))
            end
        end
    })
    contrast_label:colorpicker({
        name = "High",
        color = vars.Color3new(45/255, 45/255, 45/255), -- #2D2D2D
        flag = "theme_high",
        callback = function(color)
            if flags["theme_high"] and flags["theme_low"] then
                library:update_theme("contrast", vars.ColorSeq({
                    vars.ColorSeqKey(0, flags["theme_low"].Color),
                    vars.ColorSeqKey(1, flags["theme_high"].Color)
                }))
            end
        end
    })
    
    local inline_label = theme_section:label({name = "Inline"})
    inline_label:colorpicker({
        name = "Inline",
        color = vars.Color3new(60/255, 60/255, 60/255), -- #3C3C3C
        flag = "theme_inline",
        callback = function(color, transparency)
            library:update_theme("inline", color)
        end
    })
    inline_label:colorpicker({
        name = "Outline",
        color = vars.Color3new(0, 0, 0), -- #000000
        flag = "theme_outline",
        callback = function(color, transparency)
            library:update_theme("outline", color)
        end
    })
    
    local text_label = theme_section:label({name = "TextColor"})
    text_label:colorpicker({
        name = "Main",
        color = vars.Color3new(1, 1, 1), -- #FFFFFF
        flag = "theme_text",
        callback = function(color, transparency)
            library:update_theme("text", color)
        end
    })
    text_label:colorpicker({
        name = "Outline",
        color = vars.Color3new(0, 0, 0), -- #000000
        flag = "theme_text_outline",
        callback = function(color, transparency)
            library:update_theme("text_outline", color)
        end
    })
    
    theme_section:label({name = "Glow"}):colorpicker({
        name = "Glow",
        color = vars.Color3new(139/255, 92/255, 246/255), -- #8B5CF6
        flag = "theme_glow",
        callback = function(color, transparency)
            library:update_theme("glow", color)
        end
    })
    
    -- HUD секция
    hud_section:label({name = "UI Bind"}):keybind({
        key = Enum.KeyCode.Insert,
        flag = "ui_bind",
        callback = function(key)
            window.visible = not window.visible
        end
    })
    
    hud_section:toggle({
        name = "Keybind List",
        flag = "keybind_list",
        callback = function(enabled)
            if library.keybind_list_frame then
                library.keybind_list_frame.Visible = enabled
            end
        end
    })
    
    local watermark_toggle = hud_section:toggle({
        name = "Watermark",
        flag = "watermark",
        callback = function(enabled)
            watermark.set_visible(enabled)
            if enabled then
                watermark.change_text(utility.update_watermark_text())
            end
        end
    })
    
    hud_section:dropdown({
        name = "Watermark Type",
        flag = "watermark_type",
        items = {"Time", "Date", "Place", "User"},
        multi = true,
        default = {"Time"},
        callback = function(selected)
            watermark.change_text(utility.update_watermark_text())
        end
    })
    
    local radar_toggle = hud_section:toggle({
        name = "Radar",
        flag = "hud_radar",
        callback = function(enabled)
            radar.set_visible(enabled)
            if enabled then
                -- Добавляем всех игроков при включении радара
                for _, player in ipairs(vars.Players:GetPlayers()) do
                    if player ~= vars.LocalPlayer and radar and radar.add_dot then
                        radar.add_dot(player)
                    end
                end
            end
        end
    })
    
    hud_section:slider({
        name = "Radar Zoom",
        flag = "radar_zoom",
        min = 0.1,
        max = 2,
        default = 1,
        interval = 0.1,
        callback = function(value)
            radar.set_zoom(value)
        end
    })
    
    -- Game секция
    game_section:button_holder({})
    
    game_section:button({
        name = "Copy JobId",
        callback = function()
            setclipboard(game.JobId)
            library:notification({text = "Copied JobId to clipboard", time = 2})
        end
    })
    
    game_section:button({
        name = "Copy GameID",
        callback = function()
            setclipboard(tostring(game.GameId))
            library:notification({text = "Copied GameId to clipboard", time = 2})
        end
    })
    
    game_section:button_holder({})
    
    game_section:button({
        name = "Copy Join Script",
        callback = function()
            setclipboard(
                'game:GetService("TeleportService"):TeleportToPlaceInstance(' ..
                game.PlaceId .. ', "' .. game.JobId .. '", game.Players.LocalPlayer)'
            )
            library:notification({text = "Copied join script to clipboard", time = 2})
        end
    })
    
    game_section:button_holder({})
    
    game_section:button({
        name = "Rejoin",
        callback = function()
            vars.TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, vars.LocalPlayer)
        end
    })
    
    game_section:button_holder({})
    
    game_section:button({
        name = "Join New Server",
        callback = function()
            local url = "https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"

            local fetch_servers
            fetch_servers = function(attempts)
                attempts = attempts or 5
                local delay = 1
                for i = 1, attempts do
                    local ok, body = pcall(function()
                        return game:HttpGetAsync(url)
                    end)
                    if ok then
                        local ok2, decoded = pcall(function()
                            return vars.HttpService:JSONDecode(body)
                        end)
                        if ok2 then
                            return decoded
                        else
                            library:notification({text = "Server list decode failed", time = 2})
                            return nil
                        end
                    else
                        local msg = tostring(body)
                        if vars.str_find(msg, "429") or vars.str_find(msg, "Too Many Requests") then
                            vars.task_wait(delay + (vars.random(0, 250) / 1000))
                            delay = vars.math_min(delay * 2, 8)
                        else
                            library:notification({text = "HTTP error: " .. msg, time = 2})
                            return nil
                        end
                    end
                end
                return nil
            end

            local servers = fetch_servers()
            if not servers or not servers.data or #servers.data == 0 then
                library:notification({text = "Сервера недоступны или пустой список", time = 2})
                return
            end

            local candidates = {}
            for _, s in ipairs(servers.data) do
                if s.id ~= game.JobId and s.playing < s.maxPlayers and s.playing <= (flags["max_players"] or 15) then
                    table.insert(candidates, s)
                end
            end

            if #candidates == 0 then
                library:notification({text = "Свободных серверов не найдено", time = 2})
                return
            end

            local target = candidates[vars.random(1, #candidates)]
            vars.TeleportService:TeleportToPlaceInstance(game.PlaceId, target.id, vars.LocalPlayer)
        end
    })
    
    game_section:slider({
        name = "Max Players",
        flag = "max_players",
        min = 0,
        max = 40,
        default = 15,
        interval = 1
    })
end

-- Radar система
do
    local add_player_to_radar = function(player)
        if player ~= vars.LocalPlayer and radar and radar.add_dot then
            print("Adding player to radar:", player.Name) -- Debug
            radar.add_dot(player)
        end
    end
    
    -- Подключаем события
    table.insert(library.connections, vars.Players.PlayerAdded:Connect(add_player_to_radar))
    
    table.insert(library.connections, vars.Players.PlayerRemoving:Connect(function(player)
        if radar and radar.remove_dot then
            print("Removing player from radar:", player.Name) -- Debug
            radar.remove_dot(player)
        end
    end))
    
    -- Обновление позиций на радаре
    local radar_connection = nil
    
    local update_radar_positions = function()
        if radar and radar.update_dot then
            for _, player in ipairs(vars.Players:GetPlayers()) do
                if player ~= vars.LocalPlayer then
                    local character = player.Character
                    local root = character and character:FindFirstChild("HumanoidRootPart")
                    if root then
                        radar.update_dot(player, root.Position)
                    end
                end
            end
        end
    end
    
    -- Запускаем обновление позиций сразу
    radar_connection = vars.RunService.RenderStepped:Connect(update_radar_positions)
    table.insert(library.connections, radar_connection)
end

-- Обновление watermark каждую секунду
do
    task.spawn(function()
        while task.wait(1) do
            if flags["watermark"] then
                watermark.change_text(utility.update_watermark_text())
            end
        end
    end)
end

-- ESP Tab содержимое
do
    -- Создаем колонки для ESP вкладки
    local esp_column1 = EspTab:column()
    local esp_column2 = EspTab:column()
    
    -- Box ESP секция
    local box_section = esp_column1:section({name = "Box ESP"})
    
    box_section:toggle({
        name = "Enable Box",
        flag = "box_enable",
        callback = function(enabled)
            _G.ESP_Config.Box.Enable = enabled
        end
    })
    
    box_section:label({name = "Box Color"}):colorpicker({
        name = "Box Color",
        color = vars.Color3new(1, 1, 1),
        flag = "box_color",
        callback = function(color, transparency)
            _G.ESP_Config.Box.Color = color
        end
    })
    
    box_section:toggle({
        name = "Box Fill",
        flag = "box_fill",
        callback = function(enabled)
            _G.ESP_Config.Box.Filled.Enable = enabled
        end
    })
    
    box_section:slider({
        name = "Fill Transparency",
        flag = "box_fill_transparency",
        min = 0,
        max = 1,
        default = 0.5,
        interval = 0.01,
        callback = function(value)
            _G.ESP_Config.Box.Filled.Transparency = value
        end
    })
    
    box_section:toggle({
        name = "Gradient",
        flag = "box_gradient",
        callback = function(enabled)
            _G.ESP_Config.Box.Filled.Gradient.Enable = enabled
        end
    })
    
    local gradient_label = box_section:label({name = "Gradient Colors"})
    gradient_label:colorpicker({
        name = "Start",
        color = vars.Color3new(1, 1, 1),
        flag = "box_gradient_start",
        callback = function(color)
            _G.ESP_Config.Box.Filled.Gradient.Color.Start = color
        end
    })
    gradient_label:colorpicker({
        name = "End",
        color = vars.Color3new(0, 0, 1),
        flag = "box_gradient_end",
        callback = function(color)
            _G.ESP_Config.Box.Filled.Gradient.Color.End = color
        end
    })
    
    box_section:toggle({
        name = "Rotating Gradient",
        flag = "box_gradient_rotating",
        callback = function(enabled)
            _G.ESP_Config.Box.Filled.Gradient.Rotating.Enable = enabled
        end
    })
    
    -- Text ESP секция
    local text_section = esp_column1:section({name = "Text ESP"})
    
    text_section:slider({
        name = "Text Spacing",
        flag = "text_spacing",
        min = 5,
        max = 25,
        default = 12,
        interval = 1,
        callback = function(value)
            _G.ESP_Config.Text.Spacing = value
        end
    })
    
    -- Name Text
    text_section:toggle({
        name = "Show Name",
        flag = "text_name_enable",
        callback = function(enabled)
            _G.ESP_Config.Text.Name.Enable = enabled
        end
    })
    
    text_section:dropdown({
        name = "Name Side",
        flag = "text_name_side",
        items = {"Top", "Bot", "Left", "Right"},
        default = "Top",
        callback = function(selected)
            _G.ESP_Config.Text.Name.Side = selected
        end
    })
    
    text_section:label({name = "Name Color"}):colorpicker({
        name = "Name Color",
        color = vars.Color3new(1, 1, 1),
        flag = "text_name_color",
        callback = function(color)
            _G.ESP_Config.Text.Name.Color = color
        end
    })
    
    text_section:slider({
        name = "Name Size",
        flag = "text_name_size",
        min = 8,
        max = 20,
        default = 13,
        interval = 1,
        callback = function(value)
            _G.ESP_Config.Text.Name.Size = value
        end
    })
    
    -- Distance Text
    text_section:toggle({
        name = "Show Distance",
        flag = "text_studs_enable",
        callback = function(enabled)
            _G.ESP_Config.Text.Studs.Enable = enabled
        end
    })
    
    text_section:dropdown({
        name = "Distance Side",
        flag = "text_studs_side",
        items = {"Top", "Bot", "Left", "Right"},
        default = "Bot",
        callback = function(selected)
            _G.ESP_Config.Text.Studs.Side = selected
        end
    })
    
    text_section:label({name = "Distance Color"}):colorpicker({
        name = "Distance Color",
        color = vars.Color3new(1, 1, 1),
        flag = "text_studs_color",
        callback = function(color)
            _G.ESP_Config.Text.Studs.Color = color
        end
    })
    
    -- Tool Text
    text_section:toggle({
        name = "Show Tool",
        flag = "text_tool_enable",
        callback = function(enabled)
            _G.ESP_Config.Text.Tool.Enable = enabled
        end
    })
    
    text_section:dropdown({
        name = "Tool Side",
        flag = "text_tool_side",
        items = {"Top", "Bot", "Left", "Right"},
        default = "Bot",
        callback = function(selected)
            _G.ESP_Config.Text.Tool.Side = selected
        end
    })
    
    text_section:label({name = "Tool Color"}):colorpicker({
        name = "Tool Color",
        color = vars.Color3new(1, 1, 1),
        flag = "text_tool_color",
        callback = function(color)
            _G.ESP_Config.Text.Tool.Color = color
        end
    })
    
    -- State Text
    text_section:toggle({
        name = "Show State",
        flag = "text_state_enable",
        callback = function(enabled)
            _G.ESP_Config.Text.State.Enable = enabled
        end
    })
    
    text_section:dropdown({
        name = "State Side",
        flag = "text_state_side",
        items = {"Top", "Bot", "Left", "Right"},
        default = "Bot",
        callback = function(selected)
            _G.ESP_Config.Text.State.Side = selected
        end
    })
    
    text_section:label({name = "State Color"}):colorpicker({
        name = "State Color",
        color = vars.Color3new(1, 1, 1),
        flag = "text_state_color",
        callback = function(color)
            _G.ESP_Config.Text.State.Color = color
        end
    })
    
    -- Bars ESP секция (вторая колонка)
    local bars_section = esp_column2:section({name = "Bars ESP"})
    
    bars_section:toggle({
        name = "Enable Bars",
        flag = "bars_enable",
        callback = function(enabled)
            _G.ESP_Config.Bars.Enable = enabled
        end
    })
    
    -- Health Bar
    bars_section:toggle({
        name = "Health Bar",
        flag = "bars_health_enable",
        callback = function(enabled)
            _G.ESP_Config.Bars.Health.Enable = enabled
        end
    })
    
    bars_section:dropdown({
        name = "Health Side",
        flag = "bars_health_side",
        items = {"Left", "Right", "Top", "Bot"},
        default = "Right",
        callback = function(selected)
            _G.ESP_Config.Bars.Health.Side = selected
        end
    })
    
    bars_section:slider({
        name = "Health Width",
        flag = "bars_health_width",
        min = 1,
        max = 10,
        default = 3,
        interval = 1,
        callback = function(value)
            _G.ESP_Config.Bars.Health.Width = value
        end
    })
    
    bars_section:slider({
        name = "Health Offset",
        flag = "bars_health_offset",
        min = 0,
        max = 15,
        default = 4,
        interval = 1,
        callback = function(value)
            _G.ESP_Config.Bars.Health.Offset = value
        end
    })
    
    local health_colors = bars_section:label({name = "Health Colors"})
    health_colors:colorpicker({
        name = "High",
        color = vars.Color3new(0, 1, 0),
        flag = "bars_health_color1",
        callback = function(color)
            _G.ESP_Config.Bars.Health.Color1 = color
        end
    })
    health_colors:colorpicker({
        name = "Low",
        color = vars.Color3new(1, 0, 0),
        flag = "bars_health_color2",
        callback = function(color)
            _G.ESP_Config.Bars.Health.Color2 = color
        end
    })
    
    bars_section:toggle({
        name = "Health Lerp",
        flag = "bars_health_lerp",
        callback = function(enabled)
            _G.ESP_Config.Bars.Health.Lerp = enabled
        end
    })
    
    -- Armor Bar
    bars_section:toggle({
        name = "Armor Bar",
        flag = "bars_armor_enable",
        callback = function(enabled)
            _G.ESP_Config.Bars.Armor.Enable = enabled
        end
    })
    
    bars_section:dropdown({
        name = "Armor Side",
        flag = "bars_armor_side",
        items = {"Left", "Right", "Top", "Bot"},
        default = "Bot",
        callback = function(selected)
            _G.ESP_Config.Bars.Armor.Side = selected
        end
    })
    
    bars_section:slider({
        name = "Armor Width",
        flag = "bars_armor_width",
        min = 1,
        max = 10,
        default = 3,
        interval = 1,
        callback = function(value)
            _G.ESP_Config.Bars.Armor.Width = value
        end
    })
    
    bars_section:slider({
        name = "Armor Offset",
        flag = "bars_armor_offset",
        min = 0,
        max = 15,
        default = 4,
        interval = 1,
        callback = function(value)
            _G.ESP_Config.Bars.Armor.Offset = value
        end
    })
    
    local armor_colors = bars_section:label({name = "Armor Colors"})
    armor_colors:colorpicker({
        name = "Color1",
        color = vars.Color3new(0, 89/255, 1),
        flag = "bars_armor_color1",
        callback = function(color)
            _G.ESP_Config.Bars.Armor.Color1 = color
        end
    })
    armor_colors:colorpicker({
        name = "Color2",
        color = vars.Color3new(60/255, 97/255, 219/255),
        flag = "bars_armor_color2",
        callback = function(color)
            _G.ESP_Config.Bars.Armor.Color2 = color
        end
    })
    
    -- Team Settings секция
    local team_section = esp_column2:section({name = "Team Settings"})
    
    -- Friendly Team
    team_section:toggle({
        name = "Show Friendlies",
        flag = "team_friendly_enable",
        callback = function(enabled)
            _G.ESP_Config.TeamSettings.friendly.enabled = enabled
        end
    })
    
    team_section:toggle({
        name = "Friendly Box",
        flag = "team_friendly_box",
        callback = function(enabled)
            _G.ESP_Config.TeamSettings.friendly.box = enabled
        end
    })
    
    team_section:label({name = "Friendly Color"}):colorpicker({
        name = "Friendly Color",
        color = vars.Color3new(0, 1, 0),
        flag = "team_friendly_color",
        callback = function(color, transparency)
            _G.ESP_Config.TeamSettings.friendly.boxColor = {color, transparency or 1}
        end
    })
    
    -- Enemy Team
    team_section:toggle({
        name = "Show Enemies",
        flag = "team_enemy_enable",
        callback = function(enabled)
            _G.ESP_Config.TeamSettings.enemy.enabled = enabled
        end
    })
    
    team_section:toggle({
        name = "Enemy Box",
        flag = "team_enemy_box",
        callback = function(enabled)
            _G.ESP_Config.TeamSettings.enemy.box = enabled
        end
    })
    
    team_section:label({name = "Enemy Color"}):colorpicker({
        name = "Enemy Color",
        color = vars.Color3new(1, 0, 0),
        flag = "team_enemy_color",
        callback = function(color, transparency)
            _G.ESP_Config.TeamSettings.enemy.boxColor = {color, transparency or 1}
        end
    })
    
    -- General ESP Settings
    local general_section = esp_column2:section({name = "General"})
    
    general_section:dropdown({
        name = "Font",
        flag = "esp_font",
        items = {"ProggyClean", "ProggyTiny", "Minecraftia", "SmallestPixel7", "Verdana", "VerdanaBold", "Tahoma", "TahomaBold", "CSGO", "WindowsXPTahoma", "Stratum2", "Visitor"},
        default = "ProggyClean",
        callback = function(selected)
            _G.ESP_Config.Box.Font = selected
        end
    })
    
    general_section:toggle({
        name = "Team Check",
        flag = "esp_teamcheck",
        callback = function(enabled)
            _G.ESP_Config.Text.Name.Teamcheck = enabled
        end
    })
end

-- Обновляем список конфигов при загрузке
library:config_list_update()

-- Тема задается через colorpicker'ы выше (дефолты берутся из themes.preset)
